# Strings as Program and Currying

## Contents

* [Overview](#overview)
* [Von Neumann Architecture](#von-neumann-architecture)
    * [String and Data](#string-and-data)
    * [Code and String](#code-and-string)
    * [String as Code](#string-as-code)
    * [Minimum Description Length](#minimum-description-length)
* [Formatting Floats](#formatting-floats)
    * [Stupid Solution](#stupid-solution)
    * [Better One](#better-one)
* [Verifying Calculator](#verifying-calculator)
    * [Conventional Wisdom](#conventional-wisdom)
    * [Using Strings as Code](#using-strings-as-code)
* [Currying](#currying)
    * [General Idea](#general-idea)
    * [Partial Functions](#partial-functions)
    * [Applications](#applications)
         * [Using Back-Tick](#using-back--tick)
         * [Method Calling](#method-calling)
         * [As References](#as-references)
         * [Alternative for Reflection](#alternative-for-reflection)


## Overview

In this section we discuss about abstractions of functions, functionals, and functions
taking functions ( continued from earlier section ) as well as relationship between 
data, string, functions ( executable code). 

## Von Neumann Architecture 

All these idea started first with Alan Turings Machine, and then the 3rd implementation 
of a Turing Machine, whose innovator Von Neumann said *data is same as executable code*. 
Read more on : [Von Neumann Architecture](http://en.wikipedia.org/wiki/Von_Neumann_architecture)

Thus, one can execute arbitrary string, and call it code, if one may.
That brings in how functions are actually executed, or rather what are functions.

#### String and Data 

The idea of Von Neumann is situated under the primitive notion of  *alphabets* as *symbols*,
and the intuition that any data is representable by a finite collections of them.
The formalization of such an idea was first done by Kurt Godel, and bears his name in 
Godelization. 

For those who came from the Computer Science background, thinks in terms of data as binary streams,
which is a general idea of Kleene Closure : {0,1}\*. Even in this form, data is nothing but 
a binary *String* .


#### Code and String

Standard languages has *String* in code. In 'C' , we have "string" as constant char\*.
C++ gives us std:string , while Java has 'String'. nJexl uses Java String.
But, curiously, the whole source code, the entire JVM assembly listing can be treated as a String
by it's own right!  So, while codes has string, code itself is nothing but a string, 
which is suitable *interpreted* by a machine, more generally known as a Turing Machine.
For example, take a look around this :

     (njexl)write('Hello, World!')

This code writes 'Hello, World!' to the console. 
From the interpreter perspective, it identifies that it needs to call a function called *write*,
and pass the string literal ''Hello, World!'' to it.
But ovserve that the whole line is nothing but a string.

[Back to Contents](#contents)


#### String as Code

This brings the next idea, that can strings be, dynamically be interpreted as code?
When interpreter reads the file which it wants to interprete, it reads the instructions 
as strings. So, any string can be suitable interpreted by a suitable interpreter, 
and thus data which are strings can be interpreted as code.

#### Minimum Description Length

With this idea, we now consider this. Given a program is a String, by definition, 
can program complexity be measured as the length of the string proper?
Turns out one can, and that complexity has a name, it is called :

[Chatin Solomonoff Kolmogorov Complexity]().

The study of such is known as [Algorithmic Information Theory]() and 
the goal of a software developer becomes to write code that *reduces* this complexity.

As an example, take a look about this string :

    (njexl)s = 'ababababababababababababababababab'
    =>ababababababababababababababababab
    (njexl)#|s|
    =>34

Now, the string 's' can be easily generated by :

    (njexl)s1 = 'ab'**17
    =>ababababababababababababababababab
    (njexl)s == s1
    =>true

Thus, in nJexl, the minimum description length of the string 's' is : 8 :

    (njexl)code="'ab'**17"
    =>'ab'**17
    (njexl)#|code|
    =>8

because, there is absolutely no way to generate the string 's' with less no of characters.
And CSK folks would say : *The CSK Complexity of 's' is hence, 8 in nJexl.*

[Back to Contents](#contents)

## Formatting Floats

We take on one *highly complex* problem for which people tend to write special functions,
i.e. formatting floating point numbers after decimal digits.
The problem is that of comparing two doubles to a fixed decimal place.
Thus: 

    (njexl)x=1.01125
    =>1.01125
    (njexl)y=1.0113
    =>1.0113
    (njexl)x == y
    =>false

And we have an issue. How about we need to compare these two doubles with till 4th digit of precision (rounding) ?

#### Stupid Solution

As this has become customary to showcase *ninja* programming skills  here is one of the ways to solve it, without resorting to rounding :

    def compare_floats(d1,d2, dec_pos){
      i1 = int(d1)
      f1 = d1 - i1
      i2 = int(d2)
      f2 = d2 - i2
      
      if ( i1 != i2 ) { return false }
      while (dec_pos > 0 ){
        f1 = f1 * 10 
        f2 = f2 * 10 
        if ( int(f1) != int(f2) ) return false 
        dec_pos -= 1 
      }
      true 
    }
    write( compare_floats( 2.312, 2.3121, 2 ) )
    write( compare_floats( -2.312, -2.3121, 2 ) )

[Back to Contents](#contents)

#### Better One
The above solution fails in general, try with precision more than 2.
The reason is of course the binary representation of double and float.
How about we need to compare these two doubles with till 4th digit of precision (rounding) ?
How it would work? Well, we can use String format : 

    (njexl)str:format("%.4f",x)
    =>1.0113
    (njexl)str:format("%.4f",y)
    =>1.0113

But wait, the idea of precision, that is ".4" should it not be a parameter? Thus, one needs to pass the precision
along, something like this : 

    (njexl)c_string = "%%.%df"  ## This is the original one 
    =>%%.%df
    (njexl)p_string = str:format(c_string,4) ## apply precision, makes the string into a function 
    =>%.4f
    (njexl)str:format(p_string,y)  ## apply a number, makes the function evaluate into a proper value
    =>1.0113  # and now we have the result!

All we really did, are bloated string substitution, and in the end, that produced what we need.
Thus in a single line, we have : 
   
    (njexl)str:format(str:format(c_string,4),x)
    =>1.0113
    (njexl)str:format(str:format(c_string,4),y)
    =>1.0113

In this form, observe that the comparison function takes 3 parameters :

* The precision 
* Float 1 
* Float 2 

as the last time, but at the same time, the function is in effect generated 
by application of *partial functions*, one function taking the precision as input, 
generating the actual format string that would be used to format the float further.
These sort of taking one parameter at a time and generating partial functions 
or rather string as function is known as [currying](http://en.wikipedia.org/wiki/Currying).

[Back to Contents](#contents)

## Verifying Calculator

Suppose the task is given to verify calculator functionality.
A Calculator can do '+' , '-', '*' , ... etc all math operations.
In this case, how one proposes to write the corresponding test code?

#### Conventional Wisdom

The test code would be, invariably messy :

    if ( operation == '+' ) {
        do_plus_check();
    } else if ( operation == '-' ) {
        do_minus_check();
    }
    // some more stupidity ...

In case the one is slighly smarter, the code would be :

     switch ( operation ){
        case '+' :
           do_plus_check(); break;
        case '-' :
           do_minus_check(); break;
        ...
     }

[Back to Contents](#contents)

#### Using Strings as Code

The insight of the solution to the problem is finding the following :

>We need to test something of the form we call a "binary operator" is working "fine" or not:

    operand_1  <operator>  operand_2 

That is a general binary operator. If someone can abstract the operation out - and replace the operation with the symbol - and then someone can actually execute that resultant string as code 
(remember JVMA?) the problem would be solved.

This is faciliated by the back-tick operator ( executable strings) :

    (njexl)c_string = `#{a} #{op} #{b}`
    =>#{a} #{op} #{b}
    (njexl)a=10
    =>10
    (njexl)c_string = `#{a} #{op} #{b}`
    =>10 #{op} #{b}
    (njexl)op='+'
    =>+
    (njexl)c_string = `#{a} #{op} #{b}`
    =>10 + #{b}
    (njexl)b=10
    =>10
    (njexl)c_string = `#{a} #{op} #{b}`
    =>20
 
[Back to Contents](#contents)

## Currying 

If one looks at the the previous examples substitution patterns, one sees that it is a function of 3 parameters, 

* Operand 1 
* Operator 
* Operand 2 

Clearly, it substitutes one parameter at a time, and each substitution returning a function 
that is having one less parameter than the earlier one.
This is known as Currying.

#### General Idea

Thus, whenever there is a situation when a function is taking input and resulting in
another function, currying is a nice way to achive such things. 
However, Currying essentially means substituting one parameter at a time.

Consider this problem of checking if a point 'P(x,y)' is inside a circle of radius 'r'
which is centered at origin. We know that the condition *inside* can be written as :

     def inside(P,r){
        P.x ** 2 + P.y ** 2 < r ** 2  
     }

This can be easily achived by string substitution as :

     `#{p_x} ** 2 + #{p_y} ** 2 < #{r_v} ** 2`  

Now, we can put appropriate values one by one for p\_x and p\_y and r\_v, and 
the result would be immediate.

[Back to Contents](#contents)


#### Partial Functions

The same problem can be solved by application of partial functions:

    def radius(r){
       def _x_(x){
           def _y_(y){
              x** 2 + y**2 < r ** 2 
           }
           return _y_
       }
       return _x_ 
    }
    x = radius(3)
    y = x(2)
    write( y( 1) ) // true 
    write( y( 3) ) // false 

The result comes as expected :

    true
    false

So, Currying can also be achived by using partial functions, which accumulates
one parameter after another and then the final closure is the result.
Personally, I prefer String substitution, it is more optimal to the interpreter. 

[Back to Contents](#contents)


#### Applications

This has multiple applictions, some of which would be discussed.
But first a small design discussion, why back-tick was chosen to implement 
executable strings.

##### Using Back-Tick

I could have implemented the currying as part of the language - straight, not as a string processing.
But that would actually mean - processing the file 2 times, one for the standard notation, another for the operations overload. After all, who told you that the forms are limited?

You can have : 

    a #{op} b 
    func( a #{op} b )

and now, imagine that the #{op} can turn itself into an operator or a comma! What then?
Thus, it is theoretically impossible to 'guess' context of the operator. And thus, a better implementation is double reading by default, *ONLY* when one is forced to ask : dude, there is my back tick!
Note that, back tick returns a string, if nothing found or matched.

    (njexl)y=10
    =>10
    (njexl)x='hi'
    =>hi
    (njexl)`x.#{method}(y)`
    =>x.#{method}(y)
    (njexl)method='equals'
    =>equals
    (njexl)`x.#{method}(y)`
    =>false

You can call it - the executable (2) string. Or, you can call it a glorified macro processor.
Does not matter. Currying is essential in computer theory - and is more than essential 
if you are trying to avoid voluminous coding. 

[Back to Contents](#contents)

#####  Method calling

Calling methods can be accomplished using currying. 
The "equals" in previous section shows it. However, the idea can go much deep.

    import 'java.lang.System.out' as out 
    def func_taking_other_function( func ){
       `#{func}( 'hello!' )`
    }
    my:func_taking_other_function('out:println')

This works, as expected.

    $ njexl ../samples/curry_sample.jexl
    hello!

##### As References

Let's see how to have a *reference like* behaviour in nJexl.

    (njexl)x = [1,2]
    =>@[1, 2]
    (njexl)y = { 'x' : x }
    =>{x=[I@5b37e0d2}
    (njexl)x = [1,3,4]
    =>@[1, 3, 4]
    (njexl)y.x // x is not updated 
    =>@[1, 2]

Suppose you want a different behaviour, and that can be achived using Pointers/References.
What you want is this :

    (njexl)x = [1,2]
    =>@[1, 2]
    (njexl)y = { 'x' : 'x'  }
    =>{x=x}
    (njexl)`#{y.x}` // access as in currying stuff
    =>@[1, 2]
    (njexl)x = [1,3,4]
    =>@[1, 3, 4]
    (njexl)`#{y.x}` // as currying stuff, always updated 
    =>@[1, 3, 4]

So, in effect I am using a dictionary to hold *name* of a variable, instead of having 
a hard variable reference, thus, when I am dereferencing it, I would get back the value
if such a value exists! 

[Back to Contents](#contents)


##### Alternative for Reflection 
If currying is too hard to comprehend, then reflection is relatively simpler.
To start with we first need to find the name of the methods defined 
in a script :

    import 'java.lang.System.out' as out
    // import from another script 
    import  '_/src/lang/samples/dummy.jexl' as dummy
    //call a function  
    dummy:some_func("Hello, World!")
    // now find all functions in dummy?
    methods = dummy:methods()
    // printing methods
    out:println(methods)
    // now call same method:
    m_name = 'some_func'
    method = methods[m_name]
    method("Hello, Again!")

When one executes this, the results are what is expected :

    Hello, World!
    {some_func=ScriptMethod{ name='some_func', instance=false}, void_func=ScriptMethod{ name='void_func', instance=false}}
    Hello, Again!

So, iterating over methods of a script are easy.

[Back to Contents](#contents)



 